/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: profile.proto */

#ifndef PROTOBUF_C_profile_2eproto__INCLUDED
#define PROTOBUF_C_profile_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1003003 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif

typedef struct _PProf__Profile PProf__Profile;
typedef struct _PProf__ValueType PProf__ValueType;
typedef struct _PProf__Sample PProf__Sample;
typedef struct _PProf__Label PProf__Label;
typedef struct _PProf__Mapping PProf__Mapping;
typedef struct _PProf__Location PProf__Location;
typedef struct _PProf__Line PProf__Line;
typedef struct _PProf__Function PProf__Function;

/* --- enums --- */

/* --- messages --- */

struct _PProf__Profile {
    ProtobufCMessage base;
    /*
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     */
    size_t n_sample_type;
    PProf__ValueType **sample_type;
    /*
     * The set of samples recorded in this profile.
     */
    size_t n_sample;
    PProf__Sample **sample;
    /*
     * Mapping from address ranges to the image/binary/library mapped
     * into that address range.  mapping[0] will be the main binary.
     */
    size_t n_mapping;
    PProf__Mapping **mapping;
    /*
     * Useful program location
     */
    size_t n_location;
    PProf__Location **location;
    /*
     * Functions referenced by locations
     */
    size_t n_function;
    PProf__Function **function;
    /*
     * A common table for strings referenced by various messages.
     * string_table[0] must always be "".
     */
    size_t n_string_table;
    char **string_table;
    /*
     * frames with Function.function_name fully matching the following
     * regexp will be dropped from the samples, along with their successors.
     */
    /*
     * Index into string table.
     */
    int64_t drop_frames;
    /*
     * frames with Function.function_name fully matching the following
     * regexp will be kept, even if it matches drop_functions.
     */
    /*
     * Index into string table.
     */
    int64_t keep_frames;
    /*
     * Time of collection (UTC) represented as nanoseconds past the epoch.
     */
    int64_t time_nanos;
    /*
     * Duration of the profile, if a duration makes sense.
     */
    int64_t duration_nanos;
    /*
     * The kind of events between sampled ocurrences.
     * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
     */
    PProf__ValueType *period_type;
    /*
     * The number of events between sampled occurrences.
     */
    int64_t period;
    /*
     * Freeform text associated to the profile.
     */
    /*
     * Indices into string table.
     */
    size_t n_comment;
    int64_t *comment;
    /*
     * Index into the string table of the type of the preferred sample
     * value. If unset, clients should default to the last sample value.
     */
    int64_t default_sample_type;
};
#define PPROF__PROFILE__INIT                                                                    \
    {                                                                                           \
        PROTOBUF_C_MESSAGE_INIT(&pprof__profile__descriptor)                                    \
        , 0, NULL, 0, NULL, 0, NULL, 0, NULL, 0, NULL, 0, NULL, 0, 0, 0, 0, NULL, 0, 0, NULL, 0 \
    }

/*
 * ValueType describes the semantics and measurement units of a value.
 */
struct _PProf__ValueType {
    ProtobufCMessage base;
    /*
     * Index into string table.
     */
    int64_t type;
    /*
     * Index into string table.
     */
    int64_t unit;
};
#define PPROF__VALUE_TYPE__INIT                                 \
    {                                                           \
        PROTOBUF_C_MESSAGE_INIT(&pprof__value_type__descriptor) \
        , 0, 0                                                  \
    }

/*
 * Each Sample records values encountered in some program
 * context. The program context is typically a stack trace, perhaps
 * augmented with auxiliary information like the thread-id, some
 * indicator of a higher level request being handled etc.
 */
struct _PProf__Sample {
    ProtobufCMessage base;
    /*
     * The ids recorded here correspond to a Profile.location.id.
     * The leaf is at location_id[0].
     */
    size_t n_location_id;
    uint64_t *location_id;
    /*
     * The type and unit of each value is defined by the corresponding
     * entry in Profile.sample_type. All samples must have the same
     * number of values, the same as the length of Profile.sample_type.
     * When aggregating multiple samples into a single sample, the
     * result has a list of values that is the elemntwise sum of the
     * lists of the originals.
     */
    size_t n_value;
    int64_t *value;
    /*
     * label includes additional context for this sample. It can include
     * things like a thread id, allocation size, etc
     */
    size_t n_label;
    PProf__Label **label;
};
#define PPROF__SAMPLE__INIT                                 \
    {                                                       \
        PROTOBUF_C_MESSAGE_INIT(&pprof__sample__descriptor) \
        , 0, NULL, 0, NULL, 0, NULL                         \
    }

struct _PProf__Label {
    ProtobufCMessage base;
    /*
     * Index into string table
     */
    int64_t key;
    /*
     * At most one of the following must be present
     */
    /*
     * Index into string table
     */
    int64_t str;
    int64_t num;
    /*
     * Should only be present when num is present.
     * Specifies the units of num.
     * Use arbitrary string (for example, "requests") as a custom count unit.
     * If no unit is specified, consumer may apply heuristic to deduce the unit.
     * Consumers may also  interpret units like "bytes" and "kilobytes" as memory
     * units and units like "seconds" and "nanoseconds" as time units,
     * and apply appropriate unit conversions to these.
     */
    /*
     * Index into string table
     */
    int64_t num_unit;
};
#define PPROF__LABEL__INIT                                 \
    {                                                      \
        PROTOBUF_C_MESSAGE_INIT(&pprof__label__descriptor) \
        , 0, 0, 0, 0                                       \
    }

struct _PProf__Mapping {
    ProtobufCMessage base;
    /*
     * Unique nonzero id for the mapping.
     */
    uint64_t id;
    /*
     * Address at which the binary (or DLL) is loaded into memory.
     */
    uint64_t memory_start;
    /*
     * The limit of the address range occupied by this mapping.
     */
    uint64_t memory_limit;
    /*
     * Offset in the binary that corresponds to the first mapped address.
     */
    uint64_t file_offset;
    /*
     * The object this entry is loaded from.  This can be a filename on
     * disk for the main binary and shared libraries, or virtual
     * abstractions like "[vdso]".
     */
    /*
     * Index into string table
     */
    int64_t filename;
    /*
     * A string that uniquely identifies a particular program version
     * with high probability. E.g., for binaries generated by GNU tools,
     * it could be the contents of the .note.gnu.build-id field.
     */
    /*
     * Index into string table
     */
    int64_t build_id;
    /*
     * The following fields indicate the resolution of symbolic info.
     */
    protobuf_c_boolean has_functions;
    protobuf_c_boolean has_filenames;
    protobuf_c_boolean has_line_numbers;
    protobuf_c_boolean has_inline_frames;
};
#define PPROF__MAPPING__INIT                                 \
    {                                                        \
        PROTOBUF_C_MESSAGE_INIT(&pprof__mapping__descriptor) \
        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                       \
    }

/*
 * Describes function and line table debug information.
 */
struct _PProf__Location {
    ProtobufCMessage base;
    /*
     * Unique nonzero id for the location.  A profile could use
     * instruction addresses or any integer sequence as ids.
     */
    uint64_t id;
    /*
     * The id of the corresponding profile.Mapping for this location.
     * It can be unset if the mapping is unknown or not applicable for
     * this profile type.
     */
    uint64_t mapping_id;
    /*
     * The instruction address for this location, if available.  It
     * should be within [Mapping.memory_start...Mapping.memory_limit]
     * for the corresponding mapping. A non-leaf address may be in the
     * middle of a call instruction. It is up to display tools to find
     * the beginning of the instruction if necessary.
     */
    uint64_t address;
    /*
     * Multiple line indicates this location has inlined functions,
     * where the last entry represents the caller into which the
     * preceding entries were inlined.
     * E.g., if memcpy() is inlined into printf:
     *    line[0].function_name == "memcpy"
     *    line[1].function_name == "printf"
     */
    size_t n_line;
    PProf__Line **line;
    /*
     * Provides an indication that multiple symbols map to this location's
     * address, for example due to identical code folding by the linker. In that
     * case the line information above represents one of the multiple
     * symbols. This field must be recomputed when the symbolization state of the
     * profile changes.
     */
    protobuf_c_boolean is_folded;
};
#define PPROF__LOCATION__INIT                                 \
    {                                                         \
        PROTOBUF_C_MESSAGE_INIT(&pprof__location__descriptor) \
        , 0, 0, 0, 0, NULL, 0                                 \
    }

struct _PProf__Line {
    ProtobufCMessage base;
    /*
     * The id of the corresponding profile.Function for this line.
     */
    uint64_t function_id;
    /*
     * Line number in source code.
     */
    int64_t line;
};
#define PPROF__LINE__INIT                                 \
    {                                                     \
        PROTOBUF_C_MESSAGE_INIT(&pprof__line__descriptor) \
        , 0, 0                                            \
    }

struct _PProf__Function {
    ProtobufCMessage base;
    /*
     * Unique nonzero id for the function.
     */
    uint64_t id;
    /*
     * Name of the function, in human-readable form if available.
     */
    /*
     * Index into string table
     */
    int64_t name;
    /*
     * Name of the function, as identified by the system.
     * For instance, it can be a C++ mangled name.
     */
    /*
     * Index into string table
     */
    int64_t system_name;
    /*
     * Source file containing the function.
     */
    /*
     * Index into string table
     */
    int64_t filename;
    /*
     * Line number in source file.
     */
    int64_t start_line;
};
#define PPROF__FUNCTION__INIT                                 \
    {                                                         \
        PROTOBUF_C_MESSAGE_INIT(&pprof__function__descriptor) \
        , 0, 0, 0, 0, 0                                       \
    }

/* PProf__Profile methods */
void pprof__profile__init(PProf__Profile *message);
size_t pprof__profile__get_packed_size(const PProf__Profile *message);
size_t pprof__profile__pack(const PProf__Profile *message, uint8_t *out);
size_t pprof__profile__pack_to_buffer(const PProf__Profile *message, ProtobufCBuffer *buffer);
PProf__Profile *pprof__profile__unpack(ProtobufCAllocator *allocator, size_t len, const uint8_t *data);
void pprof__profile__free_unpacked(PProf__Profile *message, ProtobufCAllocator *allocator);
/* PProf__ValueType methods */
void pprof__value_type__init(PProf__ValueType *message);
size_t pprof__value_type__get_packed_size(const PProf__ValueType *message);
size_t pprof__value_type__pack(const PProf__ValueType *message, uint8_t *out);
size_t pprof__value_type__pack_to_buffer(const PProf__ValueType *message, ProtobufCBuffer *buffer);
PProf__ValueType *pprof__value_type__unpack(ProtobufCAllocator *allocator, size_t len, const uint8_t *data);
void pprof__value_type__free_unpacked(PProf__ValueType *message, ProtobufCAllocator *allocator);
/* PProf__Sample methods */
void pprof__sample__init(PProf__Sample *message);
size_t pprof__sample__get_packed_size(const PProf__Sample *message);
size_t pprof__sample__pack(const PProf__Sample *message, uint8_t *out);
size_t pprof__sample__pack_to_buffer(const PProf__Sample *message, ProtobufCBuffer *buffer);
PProf__Sample *pprof__sample__unpack(ProtobufCAllocator *allocator, size_t len, const uint8_t *data);
void pprof__sample__free_unpacked(PProf__Sample *message, ProtobufCAllocator *allocator);
/* PProf__Label methods */
void pprof__label__init(PProf__Label *message);
size_t pprof__label__get_packed_size(const PProf__Label *message);
size_t pprof__label__pack(const PProf__Label *message, uint8_t *out);
size_t pprof__label__pack_to_buffer(const PProf__Label *message, ProtobufCBuffer *buffer);
PProf__Label *pprof__label__unpack(ProtobufCAllocator *allocator, size_t len, const uint8_t *data);
void pprof__label__free_unpacked(PProf__Label *message, ProtobufCAllocator *allocator);
/* PProf__Mapping methods */
void pprof__mapping__init(PProf__Mapping *message);
size_t pprof__mapping__get_packed_size(const PProf__Mapping *message);
size_t pprof__mapping__pack(const PProf__Mapping *message, uint8_t *out);
size_t pprof__mapping__pack_to_buffer(const PProf__Mapping *message, ProtobufCBuffer *buffer);
PProf__Mapping *pprof__mapping__unpack(ProtobufCAllocator *allocator, size_t len, const uint8_t *data);
void pprof__mapping__free_unpacked(PProf__Mapping *message, ProtobufCAllocator *allocator);
/* PProf__Location methods */
void pprof__location__init(PProf__Location *message);
size_t pprof__location__get_packed_size(const PProf__Location *message);
size_t pprof__location__pack(const PProf__Location *message, uint8_t *out);
size_t pprof__location__pack_to_buffer(const PProf__Location *message, ProtobufCBuffer *buffer);
PProf__Location *pprof__location__unpack(ProtobufCAllocator *allocator, size_t len, const uint8_t *data);
void pprof__location__free_unpacked(PProf__Location *message, ProtobufCAllocator *allocator);
/* PProf__Line methods */
void pprof__line__init(PProf__Line *message);
size_t pprof__line__get_packed_size(const PProf__Line *message);
size_t pprof__line__pack(const PProf__Line *message, uint8_t *out);
size_t pprof__line__pack_to_buffer(const PProf__Line *message, ProtobufCBuffer *buffer);
PProf__Line *pprof__line__unpack(ProtobufCAllocator *allocator, size_t len, const uint8_t *data);
void pprof__line__free_unpacked(PProf__Line *message, ProtobufCAllocator *allocator);
/* PProf__Function methods */
void pprof__function__init(PProf__Function *message);
size_t pprof__function__get_packed_size(const PProf__Function *message);
size_t pprof__function__pack(const PProf__Function *message, uint8_t *out);
size_t pprof__function__pack_to_buffer(const PProf__Function *message, ProtobufCBuffer *buffer);
PProf__Function *pprof__function__unpack(ProtobufCAllocator *allocator, size_t len, const uint8_t *data);
void pprof__function__free_unpacked(PProf__Function *message, ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*PProf__Profile_Closure)(const PProf__Profile *message, void *closure_data);
typedef void (*PProf__ValueType_Closure)(const PProf__ValueType *message, void *closure_data);
typedef void (*PProf__Sample_Closure)(const PProf__Sample *message, void *closure_data);
typedef void (*PProf__Label_Closure)(const PProf__Label *message, void *closure_data);
typedef void (*PProf__Mapping_Closure)(const PProf__Mapping *message, void *closure_data);
typedef void (*PProf__Location_Closure)(const PProf__Location *message, void *closure_data);
typedef void (*PProf__Line_Closure)(const PProf__Line *message, void *closure_data);
typedef void (*PProf__Function_Closure)(const PProf__Function *message, void *closure_data);

/* --- services --- */

/* --- descriptors --- */

extern const ProtobufCMessageDescriptor pprof__profile__descriptor;
extern const ProtobufCMessageDescriptor pprof__value_type__descriptor;
extern const ProtobufCMessageDescriptor pprof__sample__descriptor;
extern const ProtobufCMessageDescriptor pprof__label__descriptor;
extern const ProtobufCMessageDescriptor pprof__mapping__descriptor;
extern const ProtobufCMessageDescriptor pprof__location__descriptor;
extern const ProtobufCMessageDescriptor pprof__line__descriptor;
extern const ProtobufCMessageDescriptor pprof__function__descriptor;

PROTOBUF_C__END_DECLS

#endif /* PROTOBUF_C_profile_2eproto__INCLUDED */
